<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Horizontal Scroll Timeline</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Define theme colors using CSS variables */
        :root {
            /* Light Theme (Classic/Premium) */
            --bg-start: #fcfcfc; /* Off-White/Cream */
            --bg-end: #f5f5f5;
            --text-color: #333333; /* Dark Gray text */
            --card-bg: white;
            --accent-color: #d97706; /* Amber-700 (Rich Gold/Bronze) */
            --line-color: #e0e0e0;
            --shadow-base: rgba(0, 0, 0, 0.15); /* Crisper, subtler shadow */
            --shadow-strip-base: rgba(0, 0, 0, 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                /* Dark Theme (Classic/Premium Navy/Gold) */
                --bg-start: #1e2a38; /* Deep Slate Blue */
                --bg-end: #0f172a; /* Slate-900 */
                --text-color: #f0f0f0; /* Off-White text */
                --card-bg: #293847; /* Slightly lighter card */
                --accent-color: #fbbf24; /* Amber-400 (Brighter Gold) */
                --line-color: #4b5563;
                --shadow-base: rgba(0, 0, 0, 0.7); /* Deep shadow in dark mode */
                --shadow-strip-base: rgba(0, 0, 0, 0.3); 
            }
        }

        /* Setup for the entire page */
        html {
            scroll-behavior: auto; 
            font-family: 'Inter', sans-serif;
            overflow-x: hidden; 
        }
        
        body {
            margin: 0;
            /* Use CSS variables for premium gradient background */
            background: radial-gradient(circle at 50% 10%, var(--bg-start) 0%, var(--bg-end) 100%);
            color: var(--text-color); /* Apply theme text color globally */
            transition: background 0.5s ease; /* Smooth transition when theme changes */
        }

        /* 1. The Scroll Trigger: This tall container enables vertical scrolling */
        #scroll-trigger {
            width: 100%;
            position: relative; 
        }

        /* 2. The Fixed Container: This holds the visual content and remains in place */
        #sticky-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden; 
            perspective: 1000px; 
        }

        /* 3. The Horizontal Strip: This moves left/right based on vertical scroll */
        #horizontal-scroll-strip {
            display: flex;
            height: 100%;
            will-change: transform; 
            transform-style: preserve-3d;
            
            z-index: 20; 
            
            /* REMOVED: The distracting shadow on the strip itself */
            /* box-shadow: 0 0px 50px var(--shadow-strip-base); */ 
            transition: box-shadow 0.3s ease-out; 
        }

        /* Styling for each timeline slide */
        .timeline-slide {
            flex-shrink: 0; 
            width: 100vw; 
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 4rem;
            background-color: transparent; 
        }

        /* Content Card Styling - New for premium look */
        .content-card {
            background-color: var(--card-bg); /* Use variable for card background */
            padding: 3rem;
            /* Use soft borders and softer rounded corners for classic feel */
            border-radius: 0.5rem; 
            /* Use variable for card shadow (subtle lift) */
            box-shadow: 0 5px 15px var(--shadow-base); 
            max-width: 90%;
            /* Ensure smooth transition for the dynamic JS scale transformation */
            transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94), box-shadow 0.3s, background-color 0.5s;
            z-index: 30; 
            position: relative; 
        }
        .content-card:hover {
             /* Adjusted hover shadow for both themes */
             box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4); 
        }

        /* Styling for the dot navigation */
        .timeline-dot {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); 
            cursor: pointer;
        }

        /* Persistent Timeline Line */
        #timeline-line {
            position: absolute;
            top: 10%; 
            height: 2px;
            width: 100%;
            background-color: var(--line-color); /* Use variable for line color */
            z-index: 10;
            transform: translateY(-50%); 
        }
        #timeline-progress {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 0;
            background-color: var(--accent-color); /* Use variable for accent color */
            transition: width 0.3s ease-out;
            will-change: width;
        }
    </style>
</head>
<body>

    <!-- The actual scrollable space is created by this tall container -->
    <div id="scroll-trigger"></div>

    <!-- The visual content remains fixed on the screen -->
    <div id="sticky-container"> 
        
        <!-- Persistent Timeline Line (Now higher up) -->
        <div id="timeline-line">
             <div id="timeline-progress"></div>
        </div>

        <div id="horizontal-scroll-strip">

            <!-- Slide 1: Introduction -->
            <div id="slide-1" class="timeline-slide justify-start">
                <div class="content-card max-w-xl">
                    <h1 class="text-6xl font-extrabold mb-4" style="color: var(--accent-color);">Luxury Timeline</h1>
                    <p class="text-2xl font-light text-gray-700 dark:text-gray-300">
                        Experience the difference of **velocity-driven 3D effects** and weighted scrolling in a clean, modern timeline.
                    </p>
                    <div class="mt-8 text-sm font-medium" style="color: var(--accent-color);">
                        <span class="inline-block animate-pulse">â†“</span> Scroll to Begin
                    </div>
                </div>
            </div>

            <!-- Slide 2: Feature 1 - With Image Placeholder -->
            <div id="slide-2" class="timeline-slide">
                <div class="content-card grid md:grid-cols-2 gap-12 max-w-7xl">
                    <!-- Placeholder color is now gold -->
                    <div class="rounded-lg overflow-hidden h-72 w-full flex items-center justify-center shadow-inner" style="background-color: var(--accent-color);">
                        <img src="https://placehold.co/800x600/d97706/ffffff?text=Classic+Design" alt="Abstract Feature 1" class="object-cover w-full h-full opacity-70 transition duration-500 hover:opacity-100">
                    </div>
                    <div class="flex flex-col justify-center">
                        <span class="text-lg font-semibold uppercase text-yellow-500 mb-2">Classic Experience</span>
                        <h2 class="text-4xl font-bold mb-4" style="color: var(--text-color);">
                            Weighted Movement & LERP.
                        </h2>
                        <p class="text-lg text-gray-700 dark:text-gray-300 leading-relaxed">
                            Linear Interpolation (LERP) ensures the scroll is never instant, providing the **heavy, premium inertia** that sets this experience apart from standard scrolling.
                        </p>
                    </div>
                </div>
            </div>

            <!-- Slide 3: Feature 2 - Text Focus -->
            <div id="slide-3" class="timeline-slide">
                <div class="content-card max-w-4xl text-center">
                    <span class="text-lg font-semibold uppercase text-amber-500 mb-2 block">High Fidelity</span>
                    <h2 class="text-5xl font-bold mb-6" style="color: var(--text-color);">
                        Velocity-Driven 3D Effects.
                    </h1>
                    <p class="text-xl text-gray-700 dark:text-gray-300 leading-relaxed">
                        The content doesn't just move; it scales and its shadow blurs based on your scrolling speed, creating an immersive sense of **acceleration and visual depth**.
                    </p>
                </div>
            </div>
            
            <!-- Slide 4: Conclusion -->
            <div id="slide-4" class="timeline-slide justify-end">
                <div class="content-card max-w-xl text-right">
                    <h2 class="text-6xl font-extrabold mb-4" style="color: var(--accent-color);">Next Level Web</h2>
                    <p class="text-2xl font-light text-gray-700 dark:text-gray-300">
                        A final call to action to showcase a truly unique and memorable web presence.
                    </p>
                    <!-- Use dynamic style for button background -->
                    <button class="mt-8 px-8 py-3 transition duration-300 text-white font-medium rounded-lg shadow-xl hover:shadow-2xl transform hover:scale-105"
                            style="background-color: var(--accent-color);">
                        Start Your Project
                    </button>
                </div>
            </div>

        </div>

        <!-- Fixed Navigation Dots (Indicator) -->
        <div id="timeline-dots" class="fixed right-6 top-1/2 -translate-y-1/2 z-50 flex flex-col space-y-4">
            <!-- Dot colors are handled by JS to use the theme accent -->
            <a class="timeline-dot w-4 h-4 rounded-full shadow-lg" style="background-color: var(--accent-color);" data-slide="1"></a>
            <a class="timeline-dot w-3 h-3 bg-gray-400 rounded-full" data-slide="2"></a>
            <a class="timeline-dot w-3 h-3 bg-gray-400 rounded-full" data-slide="3"></a>
            <a class="timeline-dot w-3 h-3 bg-gray-400 rounded-full" data-slide="4"></a>
        </div>

        <!-- Fixed Scroll Hint (Visual Cue) -->
        <div id="scroll-cue" class="fixed bottom-8 left-1/2 -translate-x-1/2 z-50 transition-opacity duration-500" style="color: var(--accent-color);">
            <svg class="w-10 h-10 animate-bounce" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
            </svg>
        </div>
    </div>

    <script>
        // --- High-Performance Horizontal Scroll Logic with Easing ---

        // State variables
        let scrollY = 0;
        let ticking = false;
        
        // Caching for the main elements
        const scrollTrigger = document.getElementById('scroll-trigger');
        const horizontalStrip = document.getElementById('horizontal-scroll-strip');
        const scrollCue = document.getElementById('scroll-cue'); 
        const timelineProgress = document.getElementById('timeline-progress'); 
        
        let numSlides = 0; 
        
        // Easing parameters
        let currentTranslateX = 0; 
        let targetTranslateX = 0; 
        const easingFactor = 0.05; 
        
        // Dimensions calculation
        let scrollRange = 0;
        let horizontalDistance = 0;
        
        // Caching CSS variable values for dynamic use
        let shadowStripBase = 'rgba(0, 0, 0, 0.1)';
        let accentColor = '#d97706'; // Default to light theme accent

        // NEW: Array to cache content cards for performance
        const cardElements = []; 

        // Mouse Parallax State for 3D Camera Effect
        let targetRotateX = 0; // Target rotation around X axis (tilt up/down)
        let targetRotateY = 0; // Target rotation around Y axis (tilt left/right)
        let currentRotateX = 0;
        let currentRotateY = 0;
        const tiltEasingFactor = 0.1; // Smoothness for the camera tilt
        const maxTilt = 1.5; // Max rotation in degrees (subtle movement)


        /**
         * Reads the current theme colors from CSS variables.
         */
        function readCssVariables() {
            const rootStyle = getComputedStyle(document.documentElement);
            // Read values for use in JS logic
            shadowStripBase = rootStyle.getPropertyValue('--shadow-strip-base').trim();
            accentColor = rootStyle.getPropertyValue('--accent-color').trim();
            // Note: Update navigation dots manually after theme change
            updateNavigationDots();
        }


        /**
         * Calculates the total scrollable range and the target horizontal distance.
         */
        function calculateDimensions() {
            const actualSlidesCount = document.querySelectorAll('.timeline-slide').length;
            
            // Aggressive Fallback to ensure scrollbar appears
            const expectedSlides = 4;
            if (actualSlidesCount < 2) {
                numSlides = expectedSlides;
                console.warn(`[Parallax Init] Fallback activated: Only detected ${actualSlidesCount} slides. Forcing numSlides to ${numSlides} for scroll activation.`);
            } else {
                numSlides = actualSlidesCount;
            }

            const numTransitions = numSlides > 1 ? numSlides - 1 : 0; 
            
            const viewportHeight = window.innerHeight > 0 ? window.innerHeight : 600;

            scrollRange = numTransitions * viewportHeight;
            scrollTrigger.style.height = `${scrollRange + viewportHeight}px`; 

            horizontalDistance = numTransitions * window.innerWidth;
            
            if (scrollRange <= 0) {
                console.error("Scroll range is zero or less. Vertical scrollbar may not appear.");
            }

            mapScrollToTarget(); 
        }

        /**
         * Updates the fixed navigation dots based on the current scroll position.
         */
        function updateNavigationDots() {
            if (numSlides === 0) return;

            const slideWidth = window.innerWidth;
            // Ensure slideIndex calculation is clamped properly
            const slideIndex = Math.min(numSlides, Math.max(1, Math.round(currentTranslateX / slideWidth) + 1));
            
            const dots = document.querySelectorAll('.timeline-dot');
            dots.forEach(dot => {
                const dotSlide = parseInt(dot.getAttribute('data-slide'));
                if (dotSlide === slideIndex) {
                    dot.classList.remove('bg-gray-400', 'w-3', 'h-3');
                    dot.classList.add('w-4', 'h-4', 'shadow-lg');
                    // Set active dot color via style attribute using the theme variable
                    dot.style.backgroundColor = accentColor; 
                } else {
                    // Reset to default gray color
                    dot.style.backgroundColor = ''; 
                    dot.classList.remove('w-4', 'h-4', 'shadow-lg');
                    dot.classList.add('bg-gray-400', 'w-3', 'h-3');
                }
            });
            // Update dynamic element colors manually
            document.querySelector('#scroll-cue').style.color = accentColor;
            
            // Safely update button color if it exists (for slide 4)
            const button = document.querySelector('#slide-4 button');
            if (button) {
                button.style.backgroundColor = accentColor;
            }
            
            // Safely update header colors
            document.querySelector('#slide-1 h1').style.color = accentColor;
            document.querySelector('#slide-4 h2').style.color = accentColor;
        }

        /**
         * Handles mouse movement to update the 3D tilt target.
         */
        function onMouseMove(e) {
            // Calculate normalized coordinates (-1 to 1) from center
            const centerW = window.innerWidth / 2;
            const centerH = window.innerHeight / 2;
            
            // Normalized X: -1 (left) to 1 (right)
            const normalizedX = (e.clientX - centerW) / centerW;
            // Normalized Y: -1 (top) to 1 (bottom)
            const normalizedY = (e.clientY - centerH) / centerH; 

            // Tilt Y-axis (side to side): Mouse right -> rotate right (positive Y-axis rotation)
            targetRotateY = normalizedX * maxTilt;
            // Tilt X-axis (up/down): Mouse down -> rotate up (negative X-axis rotation)
            targetRotateX = -normalizedY * maxTilt; 
        }
        
        /**
         * The core animation loop executed by requestAnimationFrame (rAF).
         */
        function render() {
            // 1. Easing (LERP): Gradually move current position toward the target
            const deltaX = targetTranslateX - currentTranslateX; 
            currentTranslateX += deltaX * easingFactor;
            
            // 2. Velocity-Driven Scaling (3D Zoom on STRIP)
            const normalizedSpeed = Math.min(1, Math.abs(deltaX) / window.innerWidth);
            // Increased scale factor for more aggressive zoom feel (0.30)
            const scaleFactor = 1.0 + (normalizedSpeed * 0.30); 

            // 3. Velocity-Driven Z-Rotation (Roll)
            const maxRotateZ = 0.5; // Subtle roll
            const rotateZ = (deltaX > 0 ? -1 : 1) * normalizedSpeed * maxRotateZ; 
            
            // 4. Easing for Mouse Tilt (RotateX and RotateY)
            currentRotateY += (targetRotateY - currentRotateY) * tiltEasingFactor;
            currentRotateX += (targetRotateX - currentRotateX) * tiltEasingFactor;
            
            // 5. Apply the combined transform (Scale, RotateZ, RotateX, RotateY, TranslateX)
            horizontalStrip.style.transform = 
                `scale(${scaleFactor.toFixed(4)}) 
                 rotateZ(${rotateZ.toFixed(2)}deg) 
                 rotateX(${currentRotateX.toFixed(2)}deg) 
                 rotateY(${currentRotateY.toFixed(2)}deg) 
                 translateX(-${currentTranslateX.toFixed(2)}px)`;
            
            // ******************************************************
            // NEW: Zoom the individual content blocks (cards) based on speed
            // ******************************************************
            if (numSlides > 0 && cardElements.length === numSlides) {
                const slideWidth = window.innerWidth;
                // Calculate the active slide index (0-based)
                // Use Math.round for accurate centering on the current slide
                const activeSlideIndex = Math.min(numSlides - 1, Math.max(0, Math.round(currentTranslateX / slideWidth)));
                
                // Calculate scale for the active card (subtle zoom, 1.0 to 1.15)
                const cardScale = 1.0 + (normalizedSpeed * 0.15); 
                
                cardElements.forEach((card, index) => {
                    let transform = 'scale(1.0)';
                    if (index === activeSlideIndex) {
                        // Apply the speed-driven zoom to the active card
                        transform = `scale(${cardScale.toFixed(4)})`;
                    }
                    
                    card.style.transform = transform;
                });
            }

            // 6. Update the Timeline Progress Line
            if (horizontalDistance > 0) {
                const progressWidth = (currentTranslateX / horizontalDistance) * 100;
                timelineProgress.style.width = `${progressWidth.toFixed(2)}%`;
            }

            // 7. Update the Timeline Navigation Dots
            updateNavigationDots();

            // Hide the scroll cue once the user has scrolled past the initial position
            if (window.scrollY > 50) {
                scrollCue.classList.add('opacity-0');
            } else {
                scrollCue.classList.remove('opacity-0');
            }

            requestAnimationFrame(render);
        }

        /**
         * Maps vertical scroll position to the target horizontal position.
         */
        function mapScrollToTarget() {
            if (scrollRange === 0) return; 

            scrollY = window.scrollY;

            // 1. Calculate scroll progress (0 to 1)
            const progress = Math.min(1, Math.max(0, scrollY / scrollRange));
            
            // 2. Map progress to the total horizontal distance
            targetTranslateX = progress * horizontalDistance;

            ticking = false;
        }
        
        /**
         * Handles the scroll event. Throttled by requestAnimationFrame.
         */
        function onScroll() {
            if (!ticking) {
                window.requestAnimationFrame(mapScrollToTarget);
                ticking = true;
            }
        }

        /**
         * Attaches event listeners and starts the render loop if dimensions are valid.
         */
        function startListenersAndRender() {
            if (scrollRange <= 0) {
                 console.error("Initialization failed after all attempts. Scroll mechanism remains inactive.");
                 return;
            }

            // Read the initial CSS variables
            readCssVariables();

            // NEW: Cache all card elements once
            document.querySelectorAll('.content-card').forEach(card => cardElements.push(card));

            // 1. Set up listeners
            window.addEventListener('scroll', onScroll, { passive: true });
            window.addEventListener('resize', calculateDimensions);
            // Add mouse move listener for the 3D camera effect
            window.addEventListener('mousemove', onMouseMove);
            
            // 2. Set up dot click handlers
            document.querySelectorAll('.timeline-dot').forEach(dot => {
                dot.addEventListener('click', handleDotClick);
            });
            
            // 3. Start the continuous rendering loop
            render();
        }


        /**
         * Handles clicking on a navigation dot to jump the vertical scroll position.
         */
        function handleDotClick(e) {
            e.preventDefault();
            const slideNumber = parseInt(e.target.getAttribute('data-slide'));
            
            const slideIndex = slideNumber - 1; 
            const numTransitions = numSlides - 1;
            
            const targetProgress = numTransitions > 0 ? slideIndex / numTransitions : 0; 
            const targetScrollY = targetProgress * scrollRange;
            
            window.scrollTo({
                top: targetScrollY,
                behavior: 'smooth'
            });
        }
        
        /**
         * Initialization function with retry logic.
         */
        function initHorizontalParallax() {
            calculateDimensions();

            if (scrollRange <= 0) {
                console.warn("Initial scroll calculation failed (scrollRange <= 0). Retrying in 200ms...");
                setTimeout(() => {
                    calculateDimensions();
                    startListenersAndRender();
                }, 200); 
            } else {
                startListenersAndRender();
            }
        }

        // Run initialization on window load
        window.onload = initHorizontalParallax;
        
        // Listen for theme changes to update cached variables immediately
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', readCssVariables);
        
    </script>
</body>
</html>