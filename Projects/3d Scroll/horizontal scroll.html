<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Horizontal Scroll Timeline</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Define theme colors using CSS variables */
        :root {
            /* Light Theme (Classic/Premium) */
            --bg-start: #fcfcfc; /* Off-White/Cream */
            --bg-end: #f5f5f5;
            --text-color: #333333; /* Dark Gray text */
            --card-bg: white;
            --accent-color: #d97706; /* Amber-700 (Rich Gold/Bronze) */
            --line-color: #d8d8d8;
            --shadow-base: rgba(0, 0, 0, 0.15); /* Crisper, subtler shadow */
            --shadow-strip-base: rgba(0, 0, 0, 0.1);
            --star-opacity: 0.1; /* Very subtle stars in light mode */
        }

        @media (prefers-color-scheme: dark) {
            :root {
                /* Dark Theme (Classic/Premium Navy/Gold) */
                --bg-start: #0b1015; /* Deep Slate Blue */
                --bg-end: #000000; /* Slate-900 */
                --text-color: #f0f0f0; /* Off-White text */
                --card-bg: #221300; /* Slightly lighter card */
                --accent-color: #fbbf24; /* Amber-400 (Brighter Gold) */
                --line-color: #37301f;
                --shadow-base: rgba(0, 0, 0, 0.7); /* Deep shadow in dark mode */
                --shadow-strip-base: rgba(0, 0, 0, 0.3); 
                --star-opacity: 1; /* Full opacity in dark mode */
            }
        }

        /* Setup for the entire page */
        html {
            scroll-behavior: auto; 
            font-family: 'Inter', sans-serif;
            overflow-x: hidden; 
        }
        
        body {
            margin: 0;
            /* Use CSS variables for premium gradient background */
            background: radial-gradient(circle at 50% 10%, var(--bg-start) 0%, var(--bg-end) 100%);
            color: var(--text-color); /* Apply theme text color globally */
            transition: background 0.5s ease; /* Smooth transition when theme changes */
        }

        /* --- 3D Starfield Background CSS --- */
        #starfield {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5; /* Behind content (z-index 20) */
            background: transparent;
            overflow: hidden;
            will-change: transform; /* NEW: Enable hardware acceleration for parallax shift */
            transition: transform 0.1s linear;
        }

        .stars {
            position: absolute;
            top: 0;
            left: 0;
            background: transparent;
            will-change: transform;
            transition: opacity 0.5s; 
        }

        /* Star Layer Definitions (Static particles in 3D space) */
        .stars-1 {
            width: 1px; height: 1px;
            box-shadow: 100px 30px #ffffff, 200px 150px #FFF, 350px 70px #FFF, 50px 500px #FFF, 600px 320px #FFF, 750px 180px #FFF, 900px 450px #FFF, 1050px 100px #FFF, 1200px 550px #FFF, 1350px 200px #FFF, 1500px 650px #FFF, 1650px 300px #FFF, 1800px 750px #FFF, 1950px 400px #FFF, 100px 850px #FFF, 250px 1500px #FFF, 400px 950px #FFF, 550px 1600px #FFF, 700px 1050px #FFF, 850px 1700px #FFF, 1000px 1150px #FFF, 1150px 1800px #FFF, 1300px 1250px #FFF, 1450px 1900px #FFF, 1600px 1350px #FFF, 1750px 2000px #FFF;
        }
        .stars-2 {
            width: 2px; height: 2px;
            box-shadow: 50px 100px #DDD, 300px 400px #DDD, 550px 200px #DDD, 800px 500px #DDD, 1050px 250px #DDD, 1300px 550px #DDD, 1550px 350px #DDD, 1800px 600px #DDD, 50px 900px #DDD, 300px 1200px #DDD, 550px 1500px #DDD, 800px 1800px #DDD, 1050px 1400px #DDD, 1300px 1700px #DDD, 1550px 1100px #DDD, 1800px 1900px #DDD;
        }
        .stars-3 {
            width: 3px; height: 3px;
            box-shadow: 150px 200px #BBB, 450px 600px #BBB, 750px 100px #BBB, 1050px 700px #BBB, 1350px 300px #BBB, 1650px 800px #BBB, 1950px 400px #BBB, 150px 1100px #BBB, 450px 1400px #BBB, 750px 1700px #BBB, 1050px 1200px #BBB, 1350px 1800px #BBB;
        }

        /* Set base opacity using the CSS variable for theme adaptation */
        .stars-1 { opacity: calc(var(--star-opacity) * 0.8); }
        .stars-2 { opacity: calc(var(--star-opacity) * 0.5); }
        .stars-3 { opacity: calc(var(--star-opacity) * 0.3); }


        /* 1. The Scroll Trigger: This tall container enables vertical scrolling */
        #scroll-trigger {
            width: 100%;
            position: relative; 
        }

        /* 2. The Fixed Container: This holds the visual content and remains in place */
        #sticky-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden; 
            perspective: 1000px; 
        }

        /* 3. The Horizontal Strip: This moves left/right based on vertical scroll */
        #horizontal-scroll-strip {
            display: flex;
            height: 100%;
            will-change: transform; 
            transform-style: preserve-3d;
            z-index: 20; 
            transition: box-shadow 0.3s ease-out; 
        }

        /* Styling for each timeline slide */
        .timeline-slide {
            flex-shrink: 0; 
            width: 100vw; 
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 4rem;
            padding-bottom: 6rem; /* Ensure padding for the bottom bar */
            background-color: transparent; 
        }

        /* Content Card Styling - New for premium look */
        .content-card {
            background-color: var(--card-bg); /* Use variable for card background */
            padding: 3rem;
            border-radius: 0.5rem; 
            box-shadow: 0 5px 15px var(--shadow-base); 
            max-width: 90%;
            /* Ensure smooth transition for the dynamic JS transformation */
            transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94), box-shadow 0.3s, background-color 0.5s;
            z-index: 30; 
            position: relative; 
            /* NEW: Ensure card itself is in 3D space for Z-translation */
            transform-style: preserve-3d;
            will-change: transform;
        }
        .content-card:hover {
             /* Adjusted hover shadow for both themes */
             box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4); 
        }

        /* Styling for the dot navigation */
        .timeline-dot {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); 
            cursor: pointer;
        }

        /* Persistent Timeline Line (Now at the bottom) */
        #timeline-line {
            position: absolute;
            bottom: 0; 
            height: 4px; 
            width: 100%;
            background-color: var(--line-color); 
            z-index: 50; 
            transform: none; 
            /* Enhanced 3D look for the container */
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1); 
            overflow: hidden; /* Important for containing the glow */
        }
        
        #timeline-progress {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 0;
            /* NEW: Richer Gold Gradient */
            background: linear-gradient(90deg, var(--accent-color) 0%, #ffdf99 100%); 
            transition: box-shadow 0.1s ease-out; /* Only smooth the glow */
            will-change: width, box-shadow; 
        }

        /* NEW: Trailing Effect Element for Speed Trail */
        #progress-trail {
            position: absolute;
            top: 0;
            height: 100%;
            /* Use a mix-blend-mode for a light effect */
            background: rgba(255, 255, 255, 0.5); 
            mix-blend-mode: screen; 
            transition: opacity 0.1s;
            will-change: width, left, opacity;
            box-shadow: 0 0 15px 5px var(--accent-color); /* Trailing glow */
            border-radius: 9999px;
        }

        @media (prefers-color-scheme: dark) {
            #progress-trail {
                background: rgba(255, 255, 255, 0.05); /* Dim trail in dark mode */
                mix-blend-mode: normal;
            }
        }

        /* NEW: Header/Nav Styling */
        #top-nav {
            /* Add backdrop for visibility against light elements */
            background: blur(var(--bg-end), 10px);
            /* opacity: 0.95; */
            /* box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1); */
            transition: background-color 0.3s, box-shadow 0.3s;
        }
        
        #brand-logo {
            font-size: 1.5rem;
            font-weight: 800;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: var(--text-color);
        }
        
        .nav-button {
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            font-weight: 500;
            transition: all 0.3s;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            white-space: nowrap; /* Prevent wrap on small screens */
        }
        .nav-button:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }
        
        /* NEW: Premium Floating Button Style for Home */
        .floating-button {
            /* Use card background, border, and shadow for a raised, floating look */
            background-color: var(--card-bg); 
            border: 1px solid var(--line-color);
            color: var(--accent-color);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        }

        @media (prefers-color-scheme: dark) {
            .floating-button {
                 /* Adjust shadow intensity for dark mode */
                 box-shadow: 0 2px 15px rgba(0, 0, 0, 0.5); 
            }
        }
        
    </style>
</head>
<body>

    <!-- NEW: Fixed Top Navigation Bar -->
    <header id="top-nav" class="fixed top-0 left-0 right-0 z-[60] p-6 flex items-center justify-between">
        <!-- 1. Home Button (Top Left) - Now uses the floating-button style -->
        <button id="home-nav-button" class="nav-button floating-button">
            Home
        </button>
        
        <!-- 2. Brand Logo (Top Center) -->
        <div id="brand-logo" class="hidden sm:block">
            Vrindopnishad
        </div>
        
        <!-- 3. Contact Button (Top Right) -->
        <button id="contact-button" class="nav-button text-white shadow-xl" style="background-color: var(--accent-color);">
            Contact Us
        </button>
    </header>

    <!-- Static 3D Space Background (Particle/Starfield) -->
    <div id="starfield">
        <div class="stars stars-1"></div>
        <div class="stars stars-2"></div>
        <div class="stars stars-3"></div>
    </div>

    <!-- The actual scrollable space is created by this tall container -->
    <div id="scroll-trigger"></div>

    <!-- The visual content remains fixed on the screen -->
    <div id="sticky-container"> 
        
        <!-- Persistent Timeline Line (Now at the bottom) -->
        <div id="timeline-line">
             <div id="timeline-progress"></div>
             <!-- NEW: Element for the trailing speed effect -->
             <div id="progress-trail"></div> 
        </div>

        <div id="horizontal-scroll-strip">

            <!-- Slide 1: Introduction -->
            <div id="slide-1" class="timeline-slide justify-start">
                <div class="content-card max-w-xl">
                    <h1 class="text-6xl font-extrabold mb-4" style="color: var(--accent-color);">Luxury Timeline</h1>
                    <p class="text-2xl font-light text-gray-700 dark:text-gray-300">
                        Experience the difference of **velocity-driven 3D effects** and weighted scrolling in a clean, modern timeline.
                    </p>
                    <div class="mt-8 text-sm font-medium" style="color: var(--accent-color);">
                        <span class="inline-block animate-pulse">↓</span> Scroll to Begin
                    </div>
                </div>
            </div>

            <!-- Slide 2: Feature 1 - With Image Placeholder -->
            <div id="slide-2" class="timeline-slide">
                <div class="content-card grid md:grid-cols-2 gap-12 max-w-7xl">
                    <!-- Placeholder color is now gold -->
                    <div class="rounded-lg overflow-hidden h-72 w-full flex items-center justify-center shadow-inner" style="background-color: var(--accent-color);">
                        <img src="https://placehold.co/800x600/d97706/ffffff?text=Classic+Design" alt="Abstract Feature 1" class="object-cover w-full h-full opacity-70 transition duration-500 hover:opacity-100">
                    </div>
                    <div class="flex flex-col justify-center">
                        <span class="text-lg font-semibold uppercase text-yellow-500 mb-2">Classic Experience</span>
                        <h2 class="text-4xl font-bold mb-4" style="color: var(--text-color);">
                            Weighted Movement & LERP.
                        </h2>
                        <p class="text-lg text-gray-700 dark:text-gray-300 leading-relaxed">
                            Linear Interpolation (LERP) ensures the scroll is never instant, providing the **heavy, premium inertia** that sets this experience apart from standard scrolling.
                        </p>
                    </div>
                </div>
            </div>

            <!-- Slide 3: Feature 2 - Text Focus -->
            <div id="slide-3" class="timeline-slide">
                <div class="content-card max-w-4xl text-center">
                    <span class="text-lg font-semibold uppercase text-amber-500 mb-2 block">High Fidelity</span>
                    <h2 class="text-5xl font-bold mb-6" style="color: var(--text-color);">
                        Velocity-Driven 3D Effects.
                    </h1>
                    <p class="text-xl text-gray-700 dark:text-gray-300 leading-relaxed">
                        The content doesn't just move; it scales and its shadow blurs based on your scrolling speed, creating an immersive sense of **acceleration and visual depth**.
                    </p>
                </div>
            </div>
            
            <!-- Slide 4: Conclusion -->
            <div id="slide-4" class="timeline-slide justify-end">
                <div class="content-card max-w-xl text-right">
                    <h2 class="text-6xl font-extrabold mb-4" style="color: var(--accent-color);">Next Level Web</h2>
                    <p class="text-2xl font-light text-gray-700 dark:text-gray-300">
                        A final call to action to showcase a truly unique and memorable web presence.
                    </p>
                    <!-- Use dynamic style for button background -->
                    <button class="mt-8 px-8 py-3 transition duration-300 text-white font-medium rounded-lg shadow-xl hover:shadow-2xl transform hover:scale-105"
                            style="background-color: var(--accent-color);">
                        Start Your Project
                    </button>
                </div>
            </div>

        </div>

        <!-- Fixed Navigation Dots (Indicator) -->
        <div id="timeline-dots" class="fixed right-6 top-1/2 -translate-y-1/2 z-50 flex flex-col space-y-4">
            <!-- Dot colors are handled by JS to use the theme accent -->
            <a class="timeline-dot w-4 h-4 rounded-full shadow-lg" style="background-color: var(--accent-color);" data-slide="1"></a>
            <a class="timeline-dot w-3 h-3 bg-gray-400 rounded-full" data-slide="2"></a>
            <a class="timeline-dot w-3 h-3 bg-gray-400 rounded-full" data-slide="3"></a>
            <a class="timeline-dot w-3 h-3 bg-gray-400 rounded-full" data-slide="4"></a>
        </div>

        <!-- Fixed Scroll Hint (Visual Cue) -->
        <div id="scroll-cue" class="fixed bottom-8 left-1/2 -translate-x-1/2 z-50 transition-opacity duration-500" style="color: var(--accent-color);">
            <svg class="w-10 h-10 animate-bounce" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
            </svg>
        </div>
    </div>

    <script>
        // --- High-Performance Horizontal Scroll Logic with Easing ---

        // State variables
        let scrollY = 0;
        let ticking = false;
        
        // Caching for the main elements
        const scrollTrigger = document.getElementById('scroll-trigger');
        const horizontalStrip = document.getElementById('horizontal-scroll-strip');
        const starfield = document.getElementById('starfield');
        const scrollCue = document.getElementById('scroll-cue'); 
        const timelineProgress = document.getElementById('timeline-progress'); 
        // NEW: Cache the progress trail element
        const progressTrail = document.getElementById('progress-trail'); 
        
        // Cache Home Button
        const homeNavButton = document.getElementById('home-nav-button');
        
        let numSlides = 0; 
        
        // Easing parameters
        let currentTranslateX = 0; 
        let targetTranslateX = 0; 
        const easingFactor = 0.05; 
        
        // Dimensions calculation
        let scrollRange = 0;
        let horizontalDistance = 0;
        
        // Caching CSS variable values for dynamic use
        let accentColor = '#d97706'; 

        // NEW: Array to cache content cards for performance
        const cardElements = []; 

        // Mouse Parallax State for 3D Camera Effect
        let targetRotateX = 0; 
        let targetRotateY = 0; 
        let currentRotateX = 0;
        let currentRotateY = 0;
        const tiltEasingFactor = 0.1; 
        const maxTilt = 1.5; 


        /**
         * Reads the current theme colors from CSS variables.
         */
        function readCssVariables() {
            const rootStyle = getComputedStyle(document.documentElement);
            accentColor = rootStyle.getPropertyValue('--accent-color').trim();
            updateNavigationDots();
        }


        /**
         * Calculates the total scrollable range and the target horizontal distance.
         */
        function calculateDimensions() {
            const actualSlidesCount = document.querySelectorAll('.timeline-slide').length;
            
            // Aggressive Fallback to ensure scrollbar appears
            const expectedSlides = 4;
            if (actualSlidesCount < 2) {
                numSlides = expectedSlides;
                console.warn(`[Parallax Init] Fallback activated: Only detected ${actualSlidesCount} slides. Forcing numSlides to ${numSlides} for scroll activation.`);
            } else {
                numSlides = actualSlidesCount;
            }

            const numTransitions = numSlides > 1 ? numSlides - 1 : 0; 
            
            const viewportHeight = window.innerHeight > 0 ? window.innerHeight : 600;

            scrollRange = numTransitions * viewportHeight;
            scrollTrigger.style.height = `${scrollRange + viewportHeight}px`; 

            horizontalDistance = numTransitions * window.innerWidth;
            
            if (scrollRange <= 0) {
                console.error("Scroll range is zero or less. Vertical scrollbar may not appear.");
            }

            mapScrollToTarget(); 
        }

        /**
         * Updates the fixed navigation dots and back button based on the current scroll position.
         */
        function updateNavigationDots() {
            if (numSlides === 0) return;

            const slideWidth = window.innerWidth;
            // Calculate the 1-based index of the slide the user is currently closest to
            const slideIndex = Math.min(numSlides, Math.max(1, Math.round(currentTranslateX / slideWidth) + 1));
            
            
            const dots = document.querySelectorAll('.timeline-dot');
            dots.forEach(dot => {
                const dotSlide = parseInt(dot.getAttribute('data-slide'));
                if (dotSlide === slideIndex) {
                    dot.classList.remove('bg-gray-400', 'w-3', 'h-3');
                    dot.classList.add('w-4', 'h-4', 'shadow-lg');
                    dot.style.backgroundColor = accentColor; 
                } else {
                    dot.style.backgroundColor = ''; 
                    dot.classList.remove('w-4', 'h-4', 'shadow-lg');
                    dot.classList.add('bg-gray-400', 'w-3', 'h-3');
                }
            });
            
            // Safely update theme-dependent element colors
            const themeElements = document.querySelectorAll('[style*="var(--accent-color)"]');
            themeElements.forEach(el => {
                // This is a simple way to re-apply the accent color for dynamic updates
                if (el.tagName === 'H1' || el.tagName === 'H2' || el.tagName === 'SPAN' || el.id === 'scroll-cue') {
                     el.style.color = accentColor;
                }
                if (el.tagName === 'BUTTON' && el.id !== 'home-nav-button') {
                    el.style.backgroundColor = accentColor;
                }
                // NOTE: The accent color for home-nav-button is now handled by the CSS class definition (.floating-button)
            });
            
        }

        /**
         * Handles mouse movement to update the 3D tilt target.
         */
        function onMouseMove(e) {
            const centerW = window.innerWidth / 2;
            const centerH = window.innerHeight / 2;
            
            const normalizedX = (e.clientX - centerW) / centerW;
            const normalizedY = (e.clientY - centerH) / centerH; 

            targetRotateY = normalizedX * maxTilt;
            targetRotateX = -normalizedY * maxTilt; 
        }
        
        /**
         * The core animation loop executed by requestAnimationFrame (rAF).
         */
        function render() {
            // 1. Easing (LERP): Gradually move current position toward the target
            const deltaX = targetTranslateX - currentTranslateX; 
            currentTranslateX += deltaX * easingFactor;
            
            // 2. Velocity-Driven Scaling (3D Zoom on STRIP)
            const normalizedSpeed = Math.min(1, Math.abs(deltaX) / window.innerWidth);
            const scaleFactor = 1.0 + (normalizedSpeed * 0.30); 

            // 3. Velocity-Driven Z-Rotation (Roll)
            const maxRotateZ = 0.5; 
            const rotateZ = (deltaX > 0 ? -1 : 1) * normalizedSpeed * maxRotateZ; 
            
            // 4. Easing for Mouse Tilt (RotateX and RotateY)
            currentRotateY += (targetRotateY - currentRotateY) * tiltEasingFactor;
            currentRotateX += (targetRotateX - currentRotateX) * tiltEasingFactor;
            
            // 5. Apply the combined transform (Scale, RotateZ, RotateX, RotateY, TranslateX)
            horizontalStrip.style.transform = 
                `scale(${scaleFactor.toFixed(4)}) 
                 rotateZ(${rotateZ.toFixed(2)}deg) 
                 rotateX(${currentRotateX.toFixed(2)}deg) 
                 rotateY(${currentRotateY.toFixed(2)}deg) 
                 translateX(-${currentTranslateX.toFixed(2)}px)`;
            
            // NEW: Background Parallax Shift (Opposite of content rotation)
            const starfieldTiltFactor = 20; 
            const starfieldX = -currentRotateY * starfieldTiltFactor; 
            const starfieldY = -currentRotateX * starfieldTiltFactor; 
            starfield.style.transform = `translate(${starfieldX.toFixed(2)}px, ${starfieldY.toFixed(2)}px)`;

            // ******************************************************
            // Positional Z-Translation (3D Depth)
            // ******************************************************
            if (numSlides > 0 && cardElements.length === numSlides) {
                const slideWidth = window.innerWidth;
                const viewportCenter = slideWidth / 2;
                const maxTranslateZ = 200; // Max depth distance (in pixels)
                
                cardElements.forEach((card, index) => {
                    const slideCenterRelative = (index * slideWidth) + (slideWidth / 2);
                    const cardCenterOnScreen = slideCenterRelative - currentTranslateX;
                    
                    const distance = Math.abs(cardCenterOnScreen - viewportCenter);
                    
                    // Normalize distance: 0 (center) to 1 (full width away)
                    const normalizedDistance = Math.min(1.0, distance / (slideWidth * 0.5)); 
                    
                    // Calculate TranslateZ (0 at center, -maxTranslateZ at edges)
                    const translateZ = -normalizedDistance * maxTranslateZ; 
                    
                    // Apply Z-translation
                    card.style.transform = `translateZ(${translateZ.toFixed(2)}px)`;
                });
            }

            // 6. Update the Timeline Progress Line
            if (horizontalDistance > 0) {
                // LERPed (smooth) progress for the main bar
                const currentProgressPercent = (currentTranslateX / horizontalDistance) * 100;
                timelineProgress.style.width = `${currentProgressPercent.toFixed(2)}%`;
                
                // Instantaneous (raw) progress based on scrollY
                const rawProgressPercent = (scrollY / scrollRange) * 100;
                
                // Trailing effect logic
                const trailDifference = rawProgressPercent - currentProgressPercent;
                const maxGlowIntensity = 0.8; 
                const glowIntensity = normalizedSpeed * maxGlowIntensity; 
                
                // 1. Update the Speed Trail element
                if (Math.abs(trailDifference) > 0.5) {
                    // If moving right (scrolling down)
                    if (trailDifference > 0) {
                        progressTrail.style.left = `${currentProgressPercent.toFixed(2)}%`;
                        progressTrail.style.width = `${trailDifference.toFixed(2)}%`;
                    } else {
                        // If moving left (scrolling up)
                        progressTrail.style.left = `${rawProgressPercent.toFixed(2)}%`;
                        progressTrail.style.width = `${Math.abs(trailDifference).toFixed(2)}%`;
                    }
                    // Increase opacity based on speed
                    progressTrail.style.opacity = Math.min(1.0, Math.abs(trailDifference) * 2); 
                } else {
                    progressTrail.style.width = '0%';
                    progressTrail.style.opacity = '0';
                }
                
                // 2. Update the main Progress Bar Glow (soft glow on acceleration)
                if (glowIntensity > 0.05) { 
                    // Adjusted shadow for a softer, focused glow
                    timelineProgress.style.boxShadow = `0 0 10px 2px ${accentColor}`; 
                } else {
                     timelineProgress.style.boxShadow = `none`;
                }
            }

            // 7. Update the Timeline Navigation Dots
            updateNavigationDots();

            // Hide the scroll cue once the user has scrolled past the initial position
            if (window.scrollY > 50) {
                scrollCue.classList.add('opacity-0');
            } else {
                scrollCue.classList.remove('opacity-0');
            }

            requestAnimationFrame(render);
        }

        /**
         * Maps vertical scroll position to the target horizontal position.
         */
        function mapScrollToTarget() {
            if (scrollRange === 0) return; 

            scrollY = window.scrollY;

            // 1. Calculate scroll progress (0 to 1)
            const progress = Math.min(1, Math.max(0, scrollY / scrollRange));
            
            // 2. Map progress to the total horizontal distance
            targetTranslateX = progress * horizontalDistance;

            ticking = false;
        }
        
        /**
         * Handles the scroll event. Throttled by requestAnimationFrame.
         */
        function onScroll() {
            if (!ticking) {
                window.requestAnimationFrame(mapScrollToTarget);
                ticking = true;
            }
        }
        
        /**
         * NEW: Handles clicking the Home button (scrolls to top).
         */
        function handleHomeClick() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }


        /**
         * Attaches event listeners and starts the render loop if dimensions are valid.
         */
        function startListenersAndRender() {
            if (scrollRange <= 0) {
                 console.error("Initialization failed after all attempts. Scroll mechanism remains inactive.");
                 return;
            }

            readCssVariables();

            // Cache all card elements once
            document.querySelectorAll('.content-card').forEach(card => cardElements.push(card));

            // 1. Set up listeners
            window.addEventListener('scroll', onScroll, { passive: true });
            window.addEventListener('resize', calculateDimensions);
            window.addEventListener('mousemove', onMouseMove);
            
            // NEW: Home Button click handler
            homeNavButton.addEventListener('click', handleHomeClick);
            
            // 2. Set up dot click handlers
            document.querySelectorAll('.timeline-dot').forEach(dot => {
                dot.addEventListener('click', handleDotClick);
            });
            
            // 3. Start the continuous rendering loop
            render();
        }


        /**
         * Handles clicking on a navigation dot to jump the vertical scroll position.
         */
        function handleDotClick(e) {
            e.preventDefault();
            const slideNumber = parseInt(e.target.getAttribute('data-slide'));
            
            const slideIndex = slideNumber - 1; 
            const numTransitions = numSlides - 1;
            
            const targetProgress = numTransitions > 0 ? slideIndex / numTransitions : 0; 
            const targetScrollY = targetProgress * scrollRange;
            
            window.scrollTo({
                top: targetScrollY,
                behavior: 'smooth'
            });
        }
        
        /**
         * Initialization function with retry logic.
         */
        function initHorizontalParallax() {
            calculateDimensions();

            if (scrollRange <= 0) {
                console.warn("Initial scroll calculation failed (scrollRange <= 0). Retrying in 200ms...");
                setTimeout(() => {
                    calculateDimensions();
                    startListenersAndRender();
                }, 200); 
            } else {
                startListenersAndRender();
            }
        }

        // Run initialization on window load
        window.onload = initHorizontalParallax;
        
        // Listen for theme changes to update cached variables immediately
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', readCssVariables);
        
    </script>
</body>
</html>